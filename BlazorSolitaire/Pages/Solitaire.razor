@page "/solitaire"
@using BlazorSolitaire.Models.Solitaire;
@using BlazorSolitaire.Models.Common.Enums;
@using BlazorSolitaire.Pages.Partials;
<h1>接龍</h1>


<div class="row">
    <div class="col-2">
        <button class="btn-primary" @onclick="NewGame">New Game</button>
    </div>
</div>
@if (Status == GameStatus.Playing)
{
    <hr />
    <div class="row">
        <div class="col-2">
            <div>
                @{ int cardCount = DrawDeck.Count; }
                @while (cardCount > 0)
                {
                    <HiddenCard CssClass="solitaire-drawdeck"
                                ClickEvent="Draw" />cardCount -= 13;
                }
                @if (DrawDeck.Count == 0)
                 {
                    <div class="solitaire-drawdeck" @onclick="ResetDrawPile">
                        <img src="images/solitaire/cardBackGrey.png" />
                    </div>
                 }
            </div>
        </div>
        <div class="col-3">
            @if (ThirdDiscard != null)
            {
                <NonDraggableCard Card="ThirdDiscard" />}
            @if (SecondDiscard != null)
            {
                <NonDraggableCard Card="SecondDiscard" />}
            @if (FirstDiscard != null)
            {
                <DraggableCard Card="FirstDiscard"
                               CssClass="solitaire-discards"
                               HandleDragStartEvent="(() => HandleDragStart(FirstDiscard))"
                               HandleDoubleClickEvent="(() => CardDoubleClick(FirstDiscard))" />}
        </div>
        <div class="col-7">
            <div class="solitaire-suitpile-container">
                <div class="row">
                    <div class="col-2">
                        <SuitDiscardPile SuitPile="ClubsPile"
                                         DraggedCard="DraggedCard"
                                         MoveActiveCardEvent="(() => MoveActiveCard(ClubsPile))"
                                         DragStartEvent="(() => HandleDragStart(ClubsPile.Last()))" />
                    </div>
                    <div class="col-2">
                        <SuitDiscardPile SuitPile="DiamondsPile"
                                         DraggedCard="DraggedCard"
                                         MoveActiveCardEvent="(() => MoveActiveCard(DiamondsPile))"
                                         DragStartEvent="(() => HandleDragStart(DiamondsPile.Last()))" />
                    </div>
                    <div class="col-2">
                        <SuitDiscardPile SuitPile="SpadesPile"
                                         DraggedCard="DraggedCard"
                                         MoveActiveCardEvent="(() => MoveActiveCard(SpadesPile))"
                                         DragStartEvent="(() => HandleDragStart(SpadesPile.Last()))" />
                    </div>
                    <div class="col-2">
                        <SuitDiscardPile SuitPile="HeartsPile"
                                         DraggedCard="DraggedCard"
                                         MoveActiveCardEvent="(() => MoveActiveCard(HeartsPile))"
                                         DragStartEvent="(() => HandleDragStart(HeartsPile.Last()))" />
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-4">
            <div class="row">
                <div class="col-md-4"></div>
                <div class="col-md-4">
                    @if (StackPile1.Any())
                    {
                        @foreach (var card in StackPile1.GetAllCards())
                        {
                            if (card.IsVisible)
                            {
                                <DraggableCard Card="card"
                                               DraggedCard="DraggedCard"
                                               CssClass="solitaire-stackpile"
                                               HandleDragStartEvent="(() => HandleDragStart(card))"
                                               HandleDoubleClickEvent="(() => CardDoubleClick(card))"
                                               HandleDropEvent="(() => DropCardOntoStack(StackPile1))" />
                            }
                            else
                            {
                                <HiddenCard CssClass="solitaire-stackpile"
                                            ClickEvent="(() => RevealCard(card, StackPile1))" />
                            }
                        }
                    }
                    else
                    {
                        <EmptyStack Pile="StackPile1"
                                    DraggedCard="DraggedCard"
                                    DropEvent="(() => DropCardOntoStack(StackPile1))" />
                    }
                </div>
                <div class="col-md-4">
                    @if (StackPile2.Any())
                    {
                        @foreach (var card in StackPile2.GetAllCards())
                        {
                            if (card.IsVisible)
                            {
                                <DraggableCard Card="card"
                                               DraggedCard="DraggedCard"
                                               CssClass="solitaire-stackpile"
                                               HandleDragStartEvent="(() => HandleDragStart(card))"
                                               HandleDoubleClickEvent="(() => CardDoubleClick(card))"
                                               HandleDropEvent="(() => DropCardOntoStack(StackPile2))" /> }
                            else
                            {
                                <HiddenCard CssClass="solitaire-stackpile"
                                            ClickEvent="(() => RevealCard(card, StackPile2))" />}
                        } }
                    else
                    {
                        <EmptyStack Pile="StackPile2"
                                    DraggedCard="DraggedCard"
                                    DropEvent="(() => DropCardOntoStack(StackPile2))" />}
                </div>
            </div>
        </div>
        <div class="col-md-8">
            <div class="row">
                <div class="col-md-2">
                    @if (StackPile3.Any())
                    {
                        @foreach (var card in StackPile3.GetAllCards())
                        {
                            if (card.IsVisible)
                            {
                                <DraggableCard Card="card"
                                               DraggedCard="DraggedCard"
                                               CssClass="solitaire-stackpile"
                                               HandleDragStartEvent="(() => HandleDragStart(card))"
                                               HandleDoubleClickEvent="(() => CardDoubleClick(card))"
                                               HandleDropEvent="(() => DropCardOntoStack(StackPile3))" /> }
                            else
                            {
                                <HiddenCard CssClass="solitaire-stackpile"
                                            ClickEvent="(() => RevealCard(card, StackPile3))" />}
                        } }
                    else
                    {
                        <EmptyStack Pile="StackPile3"
                                    DraggedCard="DraggedCard"
                                    DropEvent="(() => DropCardOntoStack(StackPile3))" />}
                </div>
                <div class="col-md-2">
                    @if (StackPile4.Any())
                    {
                        @foreach (var card in StackPile4.GetAllCards())
                        {
                            if (card.IsVisible)
                            {
                                <DraggableCard Card="card"
                                               DraggedCard="DraggedCard"
                                               CssClass="solitaire-stackpile"
                                               HandleDragStartEvent="(() => HandleDragStart(card))"
                                               HandleDoubleClickEvent="(() => CardDoubleClick(card))"
                                               HandleDropEvent="(() => DropCardOntoStack(StackPile4))" /> }
                            else
                            {
                                <HiddenCard CssClass="solitaire-stackpile"
                                            ClickEvent="(() => RevealCard(card, StackPile4))" />}
                        } }
                    else
                    {
                        <EmptyStack Pile="StackPile4"
                                    DraggedCard="DraggedCard"
                                    DropEvent="(() => DropCardOntoStack(StackPile4))" />}
                </div>
                <div class="col-md-2">
                    @if (StackPile5.Any())
                    {
                        @foreach (var card in StackPile5.GetAllCards())
                        {
                            if (card.IsVisible)
                            {
                                <DraggableCard Card="card"
                                               DraggedCard="DraggedCard"
                                               CssClass="solitaire-stackpile"
                                               HandleDragStartEvent="(() => HandleDragStart(card))"
                                               HandleDoubleClickEvent="(() => CardDoubleClick(card))"
                                               HandleDropEvent="(() => DropCardOntoStack(StackPile5))" /> }
                            else
                            {
                                <HiddenCard CssClass="solitaire-stackpile"
                                            ClickEvent="(() => RevealCard(card, StackPile5))" />}
                        } }
                    else
                    {
                        <EmptyStack Pile="StackPile5"
                                    DraggedCard="DraggedCard"
                                    DropEvent="(() => DropCardOntoStack(StackPile5))" />}
                </div>
                <div class="col-md-2">
                    @if (StackPile6.Any())
                    {
                        @foreach (var card in StackPile6.GetAllCards())
                        {
                            if (card.IsVisible)
                            {
                                <DraggableCard Card="card"
                                               DraggedCard="DraggedCard"
                                               CssClass="solitaire-stackpile"
                                               HandleDragStartEvent="(() => HandleDragStart(card))"
                                               HandleDoubleClickEvent="(() => CardDoubleClick(card))"
                                               HandleDropEvent="(() => DropCardOntoStack(StackPile6))" /> }
                            else
                            {
                                <HiddenCard CssClass="solitaire-stackpile"
                                            ClickEvent="(() => RevealCard(card, StackPile6))" />}
                        } }
                    else
                    {
                        <EmptyStack Pile="StackPile6"
                                    DraggedCard="DraggedCard"
                                    DropEvent="(() => DropCardOntoStack(StackPile6))" />}
                </div>
                <div class="col-md-2">
                    @if (StackPile7.Any())
                    {
                        @foreach (var card in StackPile7.GetAllCards())
                        {
                            if (card.IsVisible)
                            {
                                <DraggableCard Card="card"
                                               DraggedCard="DraggedCard"
                                               CssClass="solitaire-stackpile"
                                               HandleDragStartEvent="(() => HandleDragStart(card))"
                                               HandleDoubleClickEvent="(() => CardDoubleClick(card))"
                                               HandleDropEvent="(() => DropCardOntoStack(StackPile7))" /> }
                            else
                            {
                                <HiddenCard CssClass="solitaire-stackpile"
                                            ClickEvent="(() => RevealCard(card, StackPile7))" />}
                        } }
                    else
                    {
                        <EmptyStack Pile="StackPile7"
                                    DraggedCard="DraggedCard"
                                    DropEvent="(() => DropCardOntoStack(StackPile7))" />}
                </div>
                <div class="col-md-2"></div>
            </div>
        </div>
    </div>}


@code { // 使用者目前拖動的卡片
    public Card DraggedCard { get; set; }

    public GameStatus Status { get; set; } = GameStatus.NotStarted;

    // 向使用者顯示的三張棄牌。
    // FirstDiscard 是這些棄牌的最上面。
    public Card FirstDiscard { get; set; }
    public Card SecondDiscard { get; set; }
    public Card ThirdDiscard { get; set; }

    CardDeck DrawDeck = new CardDeck();

    // 未向使用者顯示的所有棄牌。
    DiscardPile DiscardPile = new DiscardPile();

    SuitPile ClubsPile = new SuitPile(CardSuit.Clubs);
    SuitPile DiamondsPile = new SuitPile(CardSuit.Diamonds);
    SuitPile SpadesPile = new SuitPile(CardSuit.Spades);
    SuitPile HeartsPile = new SuitPile(CardSuit.Hearts);

    // 7 個牌堆從左到右編號（最左邊是 1）。
    StackPile StackPile1 = new StackPile();
    StackPile StackPile2 = new StackPile();
    StackPile StackPile3 = new StackPile();
    StackPile StackPile4 = new StackPile();
    StackPile StackPile5 = new StackPile();
    StackPile StackPile6 = new StackPile();
    StackPile StackPile7 = new StackPile();

    public void NewGame()
    {
        // 將游戲狀態設置為 Playing
        Status = GameStatus.Playing;

        // 創建一個新的抽牌組和棄牌堆
        DrawDeck = new CardDeck();
        DiscardPile = new DiscardPile();

        // 重置三張棄牌的初始值
        FirstDiscard = null;
        SecondDiscard = null;
        ThirdDiscard = null;

        // 創建新的花色堆
        ClubsPile = new SuitPile(CardSuit.Clubs);
        DiamondsPile = new SuitPile(CardSuit.Diamonds);
        SpadesPile = new SuitPile(CardSuit.Spades);
        HeartsPile = new SuitPile(CardSuit.Hearts);

        // 創建 7 個新的牌堆
        StackPile1 = new StackPile();
        StackPile2 = new StackPile();
        StackPile3 = new StackPile();
        StackPile4 = new StackPile();
        StackPile5 = new StackPile();
        StackPile6 = new StackPile();
        StackPile7 = new StackPile();

        // 發牌到牌堆
        StackPile1.Add(DrawDeck.Draw());
        StackPile2.Add(DrawDeck.DrawHidden());
        StackPile3.Add(DrawDeck.DrawHidden());
        StackPile4.Add(DrawDeck.DrawHidden());
        StackPile5.Add(DrawDeck.DrawHidden());
        StackPile6.Add(DrawDeck.DrawHidden());
        StackPile7.Add(DrawDeck.DrawHidden());

        StackPile2.Add(DrawDeck.Draw());
        StackPile3.Add(DrawDeck.DrawHidden());
        StackPile4.Add(DrawDeck.DrawHidden());
        StackPile5.Add(DrawDeck.DrawHidden());
        StackPile6.Add(DrawDeck.DrawHidden());
        StackPile7.Add(DrawDeck.DrawHidden());

        StackPile3.Add(DrawDeck.Draw());
        StackPile4.Add(DrawDeck.DrawHidden());
        StackPile5.Add(DrawDeck.DrawHidden());
        StackPile6.Add(DrawDeck.DrawHidden());
        StackPile7.Add(DrawDeck.DrawHidden());

        StackPile4.Add(DrawDeck.Draw());
        StackPile5.Add(DrawDeck.DrawHidden());
        StackPile6.Add(DrawDeck.DrawHidden());
        StackPile7.Add(DrawDeck.DrawHidden());

        StackPile5.Add(DrawDeck.Draw());
        StackPile6.Add(DrawDeck.DrawHidden());
        StackPile7.Add(DrawDeck.DrawHidden());

        StackPile6.Add(DrawDeck.Draw());
        StackPile7.Add(DrawDeck.DrawHidden());

        StackPile7.Add(DrawDeck.Draw());

        StateHasChanged();
    }

    public void Draw()
    {
        // 如果有第三張棄牌的話
        if (ThirdDiscard != null)
            DiscardPile.Add(ThirdDiscard); // 把第三張棄牌加入棄牌堆(DiscardPile)

        // 如果有第二張棄牌的話
        if (SecondDiscard != null)
            ThirdDiscard = SecondDiscard; // 把第二張棄牌放在最底層(第三張棄牌)

        // 如果有第一張棄牌的話
        if (FirstDiscard != null)
            SecondDiscard = FirstDiscard; // 讓第一張棄牌成為第二張棄牌

        // 將抽牌堆的最上面抽一張牌設為第一張棄牌
        FirstDiscard = DrawDeck.Draw();

        // 讓 Blazor 知道更新顯示
        StateHasChanged();
    }

    // 如果沒有更多的牌可以抽，使用者可以執行不同的操作 ResetDrawPile()
    public void ResetDrawPile()
    {
        // 首先，將所有三張棄牌加入棄牌堆。
        DiscardPile.Add(ThirdDiscard);
        DiscardPile.Add(SecondDiscard);
        DiscardPile.Add(FirstDiscard);

        // 獲得棄牌堆中的所有牌
        var allCards = DiscardPile.GetAll();

        // 反轉 allCards 項目的順序
        allCards.Reverse();

        // 將它們添加回到抽牌堆
        foreach (var card in allCards)
        {
            DrawDeck.Add(card);
        }

        // 重置三張棄牌和棄牌堆
        FirstDiscard = null;
        SecondDiscard = null;
        ThirdDiscard = null;
        DiscardPile = new DiscardPile();
    }

    // 當開始拖動卡片時，我們必須設置 Blazor 組件的 DraggedCard 屬性，
    // Solitaire 然後將其過濾到其他需要它的組件中，例如 DraggableCard.
    public void HandleDragStart(Card selectedCard)
    {
        DraggedCard = selectedCard;
    }


    // 將單卡添加到花色牌堆中

    // 當從棄牌或堆疊拖到花色堆時，我們一次只能移動一張牌。
    // 由於無論卡片來自何處，動作都非常相似，
    // 我們可以創建通用方法 MoveActiveCard() 將目前添加 DraggedCard 到目標 SuitPile 實例
    private void MoveActiveCard(SuitPile suitPile)
    {
        MoveActiveCard(DraggedCard, suitPile);
    }

    // 然後將其作為 傳遞 MoveActiveCardEvent 給 SuitDiscardPile 實例。
    // 當卡片被放到花色牌堆上時，該事件被調用。
    private void MoveActiveCard(Card card, SuitPile suitPile)
    {
        if (FirstDiscard != null && FirstDiscard.Suit == card.Suit && FirstDiscard.Value == card.Value)
        {
            RemoveFromDiscards(card);
        }
        RemoveIfExistsInAnyStack(card);
        RemoveFromSuitPiles(card);

        suitPile.Add(card);

        StateHasChanged();
    }


    private void RemoveIfExistsInAnyStack(Card card)
    {
        StackPile1.RemoveIfExists(card);
        StackPile2.RemoveIfExists(card);
        StackPile3.RemoveIfExists(card);
        StackPile4.RemoveIfExists(card);
        StackPile5.RemoveIfExists(card);
        StackPile6.RemoveIfExists(card);
        StackPile7.RemoveIfExists(card);
    }

    // 如果拖動的卡片可以放在這個牌堆上的話
    // 則從那三張棄牌中移除拖動的卡片。
    private void RemoveFromDiscards(Card card)
    {
        if (FirstDiscard != null && FirstDiscard.Suit == card.Suit && FirstDiscard.Value == card.Value)
        {
            FirstDiscard = null;
            MoveUpDiscards();
        }
    }

    // 把三張棄牌的順序上移
    private void MoveUpDiscards()
    {
        FirstDiscard = SecondDiscard;
        SecondDiscard = ThirdDiscard;

        ThirdDiscard = DiscardPile.Pop();
    }

    // 如果拖動的卡片可以放在這個牌堆上的話
    // 則從花色堆中移除拖動的卡片。
    private void RemoveFromSuitPiles(Card card)
    {
        HeartsPile.RemoveIfExists(card);
        ClubsPile.RemoveIfExists(card);
        DiamondsPile.RemoveIfExists(card);
        SpadesPile.RemoveIfExists(card);
    }

    // 雙擊卡牌移動到花色堆
    public void CardDoubleClick(Card card)
    {
        SuitPile selectedPile = ClubsPile;   // 梅花
        switch (card.Suit)
        {
            case CardSuit.Diamonds:
                selectedPile = DiamondsPile; // 方塊
                break;

            case CardSuit.Spades:
                selectedPile = SpadesPile;   // 黑桃
                break;

            case CardSuit.Hearts:
                selectedPile = HeartsPile;   // 愛心
                break;
        }


        CheckMoveCardToSuitPile(card, selectedPile);
    }

    // 檢查是否能移動卡牌到花色堆
    private void CheckMoveCardToSuitPile(Card card, SuitPile suitPile)
    {
        if (suitPile.Suit == card.Suit && suitPile.AllowedValue == card.Value)
        {
            MoveActiveCard(card, suitPile);
        }
    }

    // 現在，當我們點擊面朝下的卡片時，我們將“翻轉”卡片並使其正面朝上
    public async Task RevealCard(Card card, StackPile pile)
    {
        var lastPileCard = pile.Last(); // 牌堆最後一張卡片

        // 如果點擊的卡片的花色與數字是等於牌堆最後一張卡片的花色與數字的話，
        // 就把牌堆最後一張卡片改成可以顯示
        if (lastPileCard.Suit == card.Suit && lastPileCard.Value == card.Value)
        {
            lastPileCard.IsVisible = true;
        }

        // 自動完成
        await AutoComplete();
    }

    public async Task DropCardOntoStack(StackPile targetStack)
    {


        // 獲取目標牌堆最上面的牌
        var card = targetStack.Last();

        bool canStack = false;
        if (card == null) // 牌堆中沒有任何卡，我們只能允許 King 國王能放下
        {
            //If the stack is empty, dragged card can only be placed
            //if it is a King.
            canStack = DraggedCard.Value == CardValue.King;
        }
        else
        {
            bool isOppositeColor = (card.IsBlack && DraggedCard.IsRed)
                                    || (card.IsRed && DraggedCard.IsBlack);

            bool isOneLessThan
                = (int)DraggedCard.Value == (((int)card.Value) - 1);

            // 如果被拖動卡片的顏色與目標牌堆的最上面牌的顏色相反，
            // 而且比目標牌堆最上面牌少一個等級的話，則可以堆疊。
            canStack = isOneLessThan && isOppositeColor;
        }

        if (canStack)
        {
            // 確定卡片來自的牌堆
            StackPile sourceStack = null;
            if (StackPile7.Contains(DraggedCard))
                sourceStack = StackPile7;
            else if (StackPile6.Contains(DraggedCard))
                sourceStack = StackPile6;
            else if (StackPile5.Contains(DraggedCard))
                sourceStack = StackPile5;
            else if (StackPile4.Contains(DraggedCard))
                sourceStack = StackPile4;
            else if (StackPile3.Contains(DraggedCard))
                sourceStack = StackPile3;
            else if (StackPile2.Contains(DraggedCard))
                sourceStack = StackPile2;
            else if (StackPile1.Contains(DraggedCard))
                sourceStack = StackPile1;

            // 如果卡片來自牌堆，則移動卡片的牌堆
            if (sourceStack != null)
            {
                MoveCardStack(targetStack, sourceStack);
            }

            // 如果該卡牌來自棄牌，則將其從那裡移除
            // 並將其添加到目標牌堆
            if (DraggedCard == FirstDiscard)
            {
                RemoveFromDiscards(DraggedCard);
                targetStack.Add(DraggedCard);
            }

            // 如果卡片來自花色堆，
            // 則將其從花色堆移除並添加到牌堆中。
            if (ClubsPile.Contains(DraggedCard)
            || DiamondsPile.Contains(DraggedCard)
            || SpadesPile.Contains(DraggedCard)
            || HeartsPile.Contains(DraggedCard))
            {
                RemoveFromSuitPiles(DraggedCard);
                targetStack.Add(DraggedCard);
            }

        }

        // 刷新介面
        StateHasChanged();
        await AutoComplete();
    }

    // 從來源牌堆移動到目標牌堆
    private void MoveCardStack(StackPile targetStack, StackPile sourceStack)
    {
        // 檢查是否有任何卡片存在*低於*拖動的卡片
        var index = sourceStack.IndexOf(DraggedCard);
        if (sourceStack.Count() >= index)
        {
            List<Card> MoveCards = new List<Card>();
            // 獲取拖卡後的所有卡
            // sourceStack.Count() 會隨著 sourceStack.Pop() 而變小，不會造成無限迴圈
            while (index < sourceStack.Count())
            {
                MoveCards.Insert(0, sourceStack.Pop()); // 在 index 為 0 的位置插入牌
            }

            foreach (var card in MoveCards)
            {
                targetStack.Add(card);
            }
        }
    }

    // 自動完成的條件:
    // 抽牌堆中沒有更多牌。
    // 棄牌中沒有更多牌。
    // 堆疊中沒有隱藏的卡片
    private async Task AutoComplete()
    {
        if (StackPile1.HasNoHiddenCards()
            && StackPile2.HasNoHiddenCards()
            && StackPile3.HasNoHiddenCards()
            && StackPile4.HasNoHiddenCards()
            && StackPile5.HasNoHiddenCards()
            && StackPile6.HasNoHiddenCards()
            && StackPile7.HasNoHiddenCards()
            && !DiscardPile.Any()
            && DrawDeck.Count == 0
            && FirstDiscard == null)
        {
            while (!ClubsPile.IsComplete || !DiamondsPile.IsComplete || !SpadesPile.IsComplete || !HeartsPile.IsComplete)
            {
                await CheckMoveStackTopCard(StackPile1);
                await CheckMoveStackTopCard(StackPile2);
                await CheckMoveStackTopCard(StackPile3);
                await CheckMoveStackTopCard(StackPile4);
                await CheckMoveStackTopCard(StackPile5);
                await CheckMoveStackTopCard(StackPile6);
                await CheckMoveStackTopCard(StackPile7);

                StateHasChanged();

            }
        }
    }


    public async Task CheckMoveStackTopCard(StackPile stackPile)
    {
        // 獲得牌堆頂牌
        var card = stackPile.Last();
        if (card != null) // 如果頂牌不為空
        {
            // 如果可能，將最上面的牌移到正確的花色堆中。
            CheckMoveCardToSuitPile(card, ClubsPile);
            CheckMoveCardToSuitPile(card, DiamondsPile);
            CheckMoveCardToSuitPile(card, SpadesPile);
            CheckMoveCardToSuitPile(card, HeartsPile);
        }
        await Task.Delay(100);
    }
}